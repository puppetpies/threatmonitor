#!/usr/bin/ruby
########################################################################
#
# Author: Brian Hood
# Email: <brianh6854@googlemail.com>
# Description: Threatmonitor HTTP Viz
#
# Analyze HTTP Traffic using Traffic Visualizer
#
########################################################################

require 'pcaplet'
require 'getoptlong'
require 'walltime'
require 'readline'
require 'mymenu'
require 'pp'

require File.expand_path(File.join(
          File.dirname(__FILE__),
          "../lib/thm.rb"))

conf = Thm::FileServices.new
conf.thmhome?

include Thm::Defaults
include Tools

class FalseClass

  def []
=begin
#<NoMethodError: undefined method `[]' for false:FalseClass>
=end
  end
  
end

class NilClass

  def strip
    # Slightly naughty as makeurl hits a bug.
=begin
exception when looping over each packet loop: #<NoMethodError: undefined method `strip' for nil:NilClass>
./thm-httpseries:120:in `block in makeurl': undefined method `strip' for nil:NilClass (NoMethodError)
	from ./thm-httpseries:118:in `each_line'
	from ./thm-httpseries:118:in `makeurl'
	from ./thm-httpseries:189:in `block in <main>'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `loop'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `each_packet'
	from ./thm-httpseries:178:in `<main>'
=end
  end
  
  def > name=nil
=begin
exception when looping over each packet loop: #<NoMethodError: undefined method `>' for nil:NilClass>
/data2/Projects/threatmonitor/lib/thm/dataservices/geolocation/geolocation.rb:47:in `block in define_component': undefined method `>' for nil:NilClass (NoMethodError)
	from /data2/Projects/threatmonitor/lib/thm/dataservices/geolocation/geolocation.rb:73:in `geoiplookup'
	from ./thm-trafviz:284:in `block in <main>'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `loop'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `each_packet'
	from ./thm-trafviz:271:in `<main>'
=end
  end
  
end

ARGV[0] = "--help" if ARGV[0] == nil
@debug = false
banner = "\e[1;34mWelcome to Threatmonitor HTTP Traffic Visualizer \e[0m\ \n"
banner << "\e[1;34m=================================================\e[0m\ \n\n"
m = %Q{  
 /\
/\/\
\/\/
 \/}

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--interface', '-i', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--snaplength', '-s', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--debug', '-d', GetoptLong::NO_ARGUMENT ],
)

opts.each do |opt, arg|
  case opt
    when '--help'
      helper = %q[
-h, --help:
   show help
   
-i, --interface - Network Interface to collect measurements from [ OPTIONAL_ARGUMENT ]

-s, --snaplength - Snaplength [ OPTIONAL_ARGUMENT ]

-d --debug

]
      puts banner
      puts helper
      exit
    when '--debug'
      @debug = true
    when '--interface'
      @interface = nil || arg
    when '--snaplength'
      @snaplength = nil || arg
  end
end

puts banner

# Trafviz DataServices
tv = Thm::DataServices::Trafviz.new
tv.reqtable = HTTP_REQUEST_TABLE
tv.reqtableua = HTTP_REQUEST_TABLE_UA
# Connect to Datastore
gloc = Thm::DataServices::Geolocation.new
gloc.datastore = DATASTORE
gloc.debug = 1
gloc.autocommit = false
gloc.dbhost = DBHOST
gloc.dbuser = DBUSER
gloc.dbpass = DBPASS
gloc.dbname = DBNAME
gloc.dbconnect

use_const_defined_unless?("INTERFACE")
use_const_defined_unless?("SNAPLENGTH")

startup = "-s #{@snaplength} -n -i #{@interface}"
puts "Trafviz - Startup Parameters: #{startup}"

module Thm

  class DataServices::Trafviz::FilterManager

    attr_reader :bookmarks, :pcapsetfilter
    
    def initialize
      @bookmarks = Array.new
      @bkm = MyMenu.new
      @bkm.settitle("Welcome to Trafviz")
      @bkm.mymenuname = "Trafviz"
      @bkm.prompt = "Trafviz"
      @pcapsetfilter = String.new
    end

    def read(file)
      b = 0
      File.open("#{Dir.home}/.thm/#{file}", 'r') {|n|
        n.each_line {|l|
          puts "\e[1;36m#{b})\e[0m\ #{l}"
          @bookmarks[b] = l
          b += 1
        }
      }
    end

    def write(file)
      @bkm.mymenuname = "Filters"
      @bkm.prompt = "\e[1;33m\Set filter>\e[0m\ "
      pcapfilter = @bkm.definemenuitem("selectfilter", true) do
        # Just needs value returned via readline block into addfilter
      end
      fltvalid = validate_filter?("#{pcapfilter}")
      if fltvalid == true
        File.open("#{Dir.home}/.thm/#{file}", 'a') {|n| # Append to filter file
          n.puts("#{addfilter}")
        }
      end
    end
    
    def set_defaults(file)
      # Add default example filters
      File.open("#{Dir.home}/.thm/#{file}", 'w') {|n|
        n.puts("webtraffic: tcp dst port 80")
        n.puts("sourceportrange: tcp src portrange 1024-65535")
      }
    end

    def validate_filter?(filter)
      begin
        Pcap::Filter.compile("#{filter}")
        puts "Filter Compile #{filter}"
        return true
      rescue Pcap::PcapError => e
        pp e
        return false
      end
    end
    
    def build_filter_menu
      @bkm.settitle("Welcome to Trafviz")
      @bkm.mymenuname = "Trafviz"
      @bkm.prompt = "Trafviz"
      @bkm.debug = 3
      pp @bookmarks
      @bookmarks.each {|n|
        func_name = n.split(":")[0]
        pcap_filter = n.split(":")[1].lstrip
        puts "#{pcap_filter}"
        # Instance Eval probably nicer
        fltvalid = validate_filter?("#{pcap_filter}") # Because validate_filter? won't exist inside instance_eval
        @bkm.instance_eval do
          pp fltvalid
          if fltvalid == true
            definemenuitem("#{func_name}") do
              @pcapsetfilter = "#{pcap_filter}"
              #thm = DataServices::Trafviz::Main.new
            end
            additemtolist("#{func_name}: #{pcap_filter}", "#{func_name};")
          end
        end
      }
      @bkm.instance_eval do
        definemenuitem("showfilter") do
          puts "Filter: #{@pcapsetfilter}"
        end
        additemtolist("Show Current Filter", "showfilter;")
      end
      @bkm.additemtolist("Display Menu", "showmenu;")
      @bkm.additemtolist("Toggle Menu", "togglemenu;")
      @bkm.additemtolist("Exit Trafviz", "exit;")
      @bkm.menu!
    end
        
    def load_filters(file)
      if File.exists?("#{Dir.home}/.thm/#{file}")
        read(file)
      else
        set_defaults(file)
        read(file)
      end
      build_filter_menu
    end
    
  end
  
end

# Main class / Startup

module Thm

  class DataServices::Trafviz::Main

    attr_accessor :startup
    
    def initialize
      @filter_const = Array.new
      @startup = String.new
      @thm = Thm::DataServices::Trafviz::FilterManager.new
    end

    def addfilter(const, filter)
      if @thm.validate_filter?(filter) == true
        filtercode = %Q{#{const} = Pcap::Filter.new('#{filter}', @trafviz.capture)}
        @filter_const << "#{const})"
        eval(filtercode)
      end
    end
    
    def commitfilters
      flts = @filter_const.join(" | ") # Build string of CONST names
      commitcode = %Q{@trafviz.add_filter(#{flts})}
      eval(flts)
    end
    
    def run!
      @trafviz = Pcaplet.new(@startup)
    end
  end

end
=begin
FILTERLIST = 'filters.lst'
a = Thm::DataServices::Trafviz::FilterManager.new
a.load_filters("#{FILTERLIST}")
a.instance_eval do
  definemenuitem("addfilter") do
    puts "Filter: #{@pcapsetfilter}"
  end
  additemtolist("Add New Filter", "write('#{FILTERLIST}');")
end
a.menu!
=end

@trafviz = Pcaplet.new(startup)
HTTP_REQUEST = Pcap::Filter.new('tcp dst port 80', @trafviz.capture)
HTTP_RESPONSE = Pcap::Filter.new('tcp src portrange 1024-65535', @trafviz.capture)

@trafviz.add_filter(HTTP_REQUEST | HTTP_RESPONSE)
@trafviz.each_packet {|pkt|
    data = pkt.tcp_data.to_s
    data_orig = data.clone # Preserve copy in its own object_id
    data_highlight = tv.text_highlighter(data_orig)
    case pkt
    when HTTP_REQUEST
      if data =~ HTTP_METHODS_REGEXP
        stwt = Stopwatch.new
        stwt.watch('start')
        path = $1
        host = "#{pkt.dst.to_s}:\e[1;33m#{pkt.dport}\e[0m\ "
        s = "\e[1;33m#{pkt.src}:\e[1;31m#{pkt.sport}\e[0m\ > GET \e[1;33mhttp://#{host}\e[1;32mHTTP/1.1\e[0m "
        geo = gloc.geoiplookup(host.split(":")[0])
        puts "\e[4;36mGeo Location:\e[0m\ \n\e[0;35m#{geo} \e[0m\ "
        puts "\e[4;36mRequest Data:\e[0m\ \n\e[0;32m#{data_highlight} \e[0m\ "
        tv.makeurl(data_orig)
        # Process data and prepare then send elsewhere
        query_return_sql = tv.request_filter(data)
        # Store data into Datastore
        begin
          query_return_sql.each {|sql|
            ires = gloc.query("#{sql}")
            if @debug == true
              puts "\e[4;36mStructured Query:\e[0m\ #{sql} \e[4;36mResult:\e[0m\ #{ires}"
            end
          }
        rescue
          Tools::log_errors("/tmp/thm-sql-errors.log", "SQL Error - #{Time.now} - #{query_return_sql}") unless query_return_sql == "SELECT 1;"
        end
        stwt.watch('stop')
        stwt.print_stats
      elsif data =~ %r=^POST $=
        puts data_highlight
      end
    when HTTP_RESPONSE
      if data =~ HTTP_METHODS_REGEXP_RESPONSE
        stwt = Stopwatch.new
        stwt.watch('start')
        status = $1
        s = "#{pkt.dst}:#{pkt.dport} < #{status}"
        puts "\e[1;31mResponse Data: #{data_highlight} \e[0m\ "
        stwt.watch('stop')
        stwt.print_stats
      end
    end
  puts s.gsub("GET", "\e[1;36mGET\e[0m").gsub("POST", "\e[1;36mPOST\e[0m") if s
}
