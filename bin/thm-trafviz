#!/usr/bin/ruby
########################################################################
#
# Author: Brian Hood
#
# Description: Threatmonitor HTTP Viz
#
# Analyze HTTP Traffic using Traffic Visualizer
#
########################################################################

require 'pcaplet'
require 'getoptlong'
require 'keycounter'
require 'walltime'

require File.expand_path(File.join(
          File.dirname(__FILE__),
          "../lib/thm.rb"))

conf = Thm::FileServices.new
conf.thmhome?

include Thm::Defaults

class Keycounter
  
  # Essentially custom def for this program
  def keycount_createtablethm
    fieldlst = Array.new
    if File.exists?("/tmp/thmreadtable.txt")
      File.open("/tmp/thmreadtable.txt", 'r') {|n|
        n.each_line {|l|
          fieldlst << ["#{l}"]
        }
      }
    end
    sql = "CREATE TABLE http_request (\n"
    sql << "guid char(36),\n"
    instance_variables.each {|n|
      t = n.to_s.gsub("@", "")
      fieldlst << ["#{t}"]
    }
    fieldlst.each {|n|
      sql << "#{n} string,\n"
    }
    sql = sql[0..sql.size - 2]
    sql << "\n);\n"
    b = fieldlst.uniq.sort
    pp b
    File.open("/tmp/thmreadtable.txt", 'w') {|n|
      b.each {|j|
        n.puts(j)
      }
    }
    puts "\e[4;36mCreate table:\e[0m\ \n #{sql}"
  end
  
end

class NilClass

  def strip
    # Slightly naughty as makeurl hits a bug.
=begin
exception when looping over each packet loop: #<NoMethodError: undefined method `strip' for nil:NilClass>
./thm-httpseries:120:in `block in makeurl': undefined method `strip' for nil:NilClass (NoMethodError)
	from ./thm-httpseries:118:in `each_line'
	from ./thm-httpseries:118:in `makeurl'
	from ./thm-httpseries:189:in `block in <main>'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `loop'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `each_packet'
	from ./thm-httpseries:178:in `<main>'
=end
  end
  
end

ARGV[0] = "--help" if ARGV[0] == nil
@debug = false
banner = "\e[1;34mWelcome to Threatmonitor HTTP Traffic Visualizer \e[0m\ \n"
banner << "\e[1;34m=================================================\e[0m\ \n\n"

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--countheaders', '-c', GetoptLong::NO_ARGUMENT ],
  [ '--interface', '-i', GetoptLong::REQUIRED_ARGUMENT],
  [ '--debug', '-d', GetoptLong::NO_ARGUMENT ],
)

opts.each do |opt, arg|
  case opt
    when '--help'
      helper = %q[
-h, --help:
   show help
   
-c, --countheaders - Count HTTP Header types ( Builds a create table statement )[ NO_ARGUMENT ]

-i, --interface -- Network Interface to collect measurements from [ REQUIRED_ARGUMENT ]

-d --debug

]
      puts banner
      puts helper
      exit
    when '--countheaders'
      @countheaders = true
      @k = Keycounter.new
      @f = 0
      puts "Counters Enabled"
    when '--debug'
      @debug = true
    when '--interface'
      @interface = arg
  end
end

puts banner

# Trafviz DataServices
tv = Thm::DataServices::Trafviz.new
# Connect to Datastore
gloc = Thm::DataServices::Geolocation.new
gloc.datastore = DATASTORE
gloc.debug = false
gloc.autocommit = true
gloc.dbhost = DBHOST
gloc.dbuser = DBUSER
gloc.dbpass = DBPASS
gloc.dbname = DBNAME
gloc.dbconnect

# Regexp strings first currently excludes POST Data
HTTP_METHODS_REGEXP = %r=^GET |^HEAD |^PUT |^TRACE |^CONNECT |^OPTIONS |^DELETE |^PROPFIND |^PROPPATCH |^MKCOL |^COPY |^MOVE |^LOCK |^UNLOCK =
HTTP_METHODS_REGEXP_RESPONSE = %r=^(HTTP\/.*)$=
httpdump = Pcaplet.new("-s 1500 -n -i #{@interface}")
HTTP_REQUEST  = Pcap::Filter.new('tcp dst port 80', httpdump.capture)
HTTP_RESPONSE = Pcap::Filter.new('tcp src portrange 1024-65535', httpdump.capture)
httpdump.add_filter(HTTP_REQUEST | HTTP_RESPONSE)

httpdump.each_packet {|pkt|
  begin
    data = pkt.tcp_data.to_s
    data_highlight = tv.text_highlighter(data)
    case pkt
    when HTTP_REQUEST
      if data =~ HTTP_METHODS_REGEXP
        stwt = Stopwatch.new
        stwt.watch('start')
        path = $1
        host = pkt.dst.to_s
        host << ":\e[1;33m#{pkt.dport}\e[0m\ "
        s = "\e[1;33m#{pkt.src}:\e[1;31m#{pkt.sport}\e[0m\ > GET \e[1;33mhttp://#{host}\e[1;32mHTTP/1.1\e[0m "
        geo = gloc.geoiplookup(host.split(":")[0])
        puts "\e[4;36mGeo Location:\e[0m\ \n\e[0;35m#{geo} \e[0m\ "
        puts "\e[4;36mRequest Data:\e[0m\ \n\e[0;32m#{data_highlight} \e[0m\ "
        tv.makeurl(data)
        # Process data and prepare then send elsewhere
        query_return_sql = tv.request_filter(data)
        # Store data into InfluxDB API Capture if @mtable exists else Datastore
        begin
          ires = gloc.query("#{query_return_sql}")
          if @debug == true
            puts "\e[4;36mStructured Query:\e[0m\ #{query_return_sql} \e[4;36mResult:\e[0m\ #{ires}"
          end
        rescue
          Tools::log_errors("/tmp/thm-sql-errors.log", "SQL Error - #{query_return_sql}") # Catch them all
        end
        stwt.watch('stop')
        stwt.print_stats
      end
    when HTTP_RESPONSE
      if data =~ HTTP_METHODS_REGEXP_RESPONSE
        stwt = Stopwatch.new
        stwt.watch('start')
        status = $1
        s = "#{pkt.dst}:#{pkt.dport} < #{status}"
        puts "\e[1;31mResponse Data: #{data_highlight} \e[0m\ "
        stwt.watch('stop')
        stwt.print_stats
      end
    end
  rescue => e
    puts e
  end
  puts s.gsub("GET", "\e[1;36mGET\e[0m") if s
}
