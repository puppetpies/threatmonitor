#!/usr/bin/ruby
########################################################################
#
# Author: Brian Hood
#
# Description: Threatmonitor HTTP Time Series
#
# Analyze HTTP Traffic using InfluxDB
#
########################################################################

=begin
data = %Q{POST /pub/api.php?action=applicationRun&appBuild=813493&appId=95&appVersion=5.9&country=GB&currentTime=1435583909&deviceName=samsung%20GT-I8160&language=en&libVersion=3.3.1%3A5815&openUDID=938ae1e8fd90e10a644dc5c504ddc473&platform=Android&protocol=1.0&systemVersion=2.3.6&hash=17f12455fee69fda19d95635ab02c0e0 HTTP/1.1
User-Agent: MRGSHTTPRequest
ref: bdd097244832f3b2a60c11ddb9976275
action: applicationRun
Content-Length: 1466
Content-Type: multipart/form-data; boundary=Lw05lkVKD3lJpmdotDKGbrAbUNsLuMQJ0lh
Host: mrgs.my.com
Connection: Keep-Alive
}

Response Data: HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=UTF-8
Content-Length: 851
Date: Fri, 24 Jul 2015 13:05:19 GMT

{"tapjoy":1,"boostermoney":1,"result":1,"mtimer":31,"premiumvideos":0,"spezial":"","sponsorpay":1,"screenaktiv":0,"addapptr":0,"faq":"http://mfc-wiki.krassgames.com/index.php/mfaq","inapps":{"item4":{"product_id":"paket5","grafik":5,"credits":16000,"prozent":60},"item2":{"product_id":"paket3","grafik":3,"credits":3250,"prozent":30},"item3":{"product_id":"paket4","grafik":4,"credits":7000,"prozent":40},"item1":{"product_id":"paket2","grafik":2,"credits":1200,"prozent":20},"item6":{"product_id":"paket7","grafik":6,"credits":100000,"prozent":100},"item0":{"product_id":"paket1","grafik":1,"credits":500,"prozent":0},"item5":{"product_id":"paket6","grafik":6,"credits":45000,"prozent":80}},"rtg":0,"deviceid":"A428E53D-A521-4C63-9B63-1714F60D69C7","pokalaktiv":0,"infoaktiv":0,"ntimer":49,"flurry":1,"ab":1,"spezialuser":"","sw":0,"videos_off_96":0}  

insert into starbucks,charset=3,useragent=155,host=155,connection=155,acceptencoding=144,accept=149,referer=140,acceptlanguage=135,cookie=98,ifnonematch=12,xclientdata=12,resourcefreshness=4,ifmodifiedsince=18,xrequestedwith=4,origin=3,authorization=1,cachecontrol=4,cachecontrol=4,date=1,pragma=1,location=1,acc=2,contentlength=1,xigcapabilities=28,dnt=64,xclientdata=15,purpose=1,xgeo=1,csp=3 value=0.1

insert into star1,charset=3,useragent=155,host=155 value=0.1

=end

require 'pcaplet'
require 'getoptlong'
require File.expand_path(File.join(
          File.dirname(__FILE__),
          "../lib/thm.rb"))

conf = Thm::FileServices.new
conf.thmhome?

include Thm::Defaults

class NilClass

  def strip
    # Slightly naughty as makeurl hits a bug.
=begin
exception when looping over each packet loop: #<NoMethodError: undefined method `strip' for nil:NilClass>
./thm-httpseries:120:in `block in makeurl': undefined method `strip' for nil:NilClass (NoMethodError)
	from ./thm-httpseries:118:in `each_line'
	from ./thm-httpseries:118:in `makeurl'
	from ./thm-httpseries:189:in `block in <main>'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `loop'
	from /usr/lib/ruby/gems/2.1.0/gems/pcap-0.7.7/lib/pcaplet.rb:94:in `each_packet'
	from ./thm-httpseries:178:in `<main>'
=end
  end
  
end

class Keycounter

  # Create / Add to instance variable
  def keycount(key)
    key.gsub!(" ", "_") # no spaces or case
    if !instance_variable_get("@#{key}")
      instance_variable_set("@#{key}", 1)
    else
      instance_variable_set("@#{key}", instance_variable_get("@#{key}") + 1)
    end
    puts "Key: #{key} Value: "+instance_variable_get("@#{key}").to_s
  end

  # Read a single key
  def keycount_reader(key)
    key.gsub!(" ", "_") # no spaces or case
    valnum = instance_variable_get("@#{key}")
    return valnum
  end

  # Compile in array with the totals of all instance variables
  def keycount_compile
    keycounts = Array.new
    # You can't really inherit this class as the other class may also contain instance variables
    # its not really an exact logic this class only works alone.
    instance_variables.each {|n|
      t = n.to_s.gsub("@", "")
      keycounts << ["#{t}", instance_variable_get("#{n}")]
    }
    return keycounts
    keycounts
  end

end

ARGV[0] = "--help" if ARGV[0] == nil

banner = "\e[1;34mWelcome to Threatmonitor HTTP Series measurements \e[0m\ \n"
banner << "\e[1;34m=================================================\e[0m\ \n"

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--countheaders', '-c', GetoptLong::NO_ARGUMENT ],
  [ '--mtable', '-m', GetoptLong::REQUIRED_ARGUMENT],
  [ '--interface', '-i', GetoptLong::REQUIRED_ARGUMENT],
  [ '--startnewtable', '-s', GetoptLong::NO_ARGUMENT]
)

opts.each do |opt, arg|
  case opt
    when '--help'
      helper = %q[
-h, --help:
   show help
   
-c, --countheaders - Count HTTP Header types [ NO_ARGUMENT ]

-m, --mtable - Measurements Table to store data [ REQUIRED_ARGUMENT ]

-i, --interface -- Network Interface to collect measurements from [ REQUIRED_ARGUMENT ]

-s, --startnewtable - Intialize table for new captures

]
      puts banner
      puts helper
      exit
    when '--pcapfile'
      @pcapfile = arg
    when '--countheaders'
      @countheaders = 1
      @k = Keycounter.new
      @f = 0
      puts "Counters Enabled"
    when '--mtable'
      @mtable = arg
    when '--interface'
      @interface = arg
    when '--startnewtable'
      @startnewtable = arg
  end
end

puts banner

def makeurl(data)
  hdrs = data
  hostn, requestn = ""
  hdrs.each_line {|n|
    if n.split(":")[0] == "Host"
      hostn = n.split(":")[1].strip
    elsif n.split(" ")[0] == "GET"
      requestn = n.split(" ")[1]
    end
  }
  puts "\e[1;37mURL: http://#{hostn}#{requestn} \e[0m\ "
end

def request_filter(mtable, data, keysamples=500)
  lkey, rkey = ""
  q = "#{mtable},"
  puts "Influx Data: "
  t = 0
  data.each_line {|n|
    unless n.strip == ""
      if t > 0 # Don't processes GET / POST Line
        lkey = n.split(":")[0].downcase.gsub("-", "").to_s.strip
        if lkey == "cookie"
          rkeyenc = "cookieommited"
        else
          rkey = n.split(":")[1].to_s.gsub(",", "").gsub(";", "").gsub("=", "").strip
          rkeyenc = URI.encode(rkey)
        end
        if rkeyenc.strip != "" or lkey.strip != ""
          q << "#{lkey}=#{rkeyenc},"
        end
        # Keycounter / HTTP Headers counter
        if @countheaders == true
          # Keysamples: For Headers counter number of output lines to sample before exit.
          if @f < keysamples
            if lkey != ""
              @k.keycount("#{lkey}")
              @f = @f + 1
            end
          else
            pp @k.keycount_compile
            puts "Real exit..."
            exit
          end
        end
      end
      t = t + 1
    end
  }
  q = q[0..q.size - 2] # Detract comma
  q << " value=0.1"
  puts q
  return q
end

def log_errors(file, data)
  File.open("#{file}", 'a') {|n|
    n.puts("#{data}")
  }
end

# InfluxDB Connection info
sd = DatalayerLight::InfluxDB.new
sd.dbhost = "172.17.0.3"
sd.dbname = "threatmonitor"
if defined?(@startnewtable)
  # Initialize new table for measurements
  j = sd.query("#{@mtable},charset=3,useragent=155,host=155,connection=155,acceptencoding=144,accept=149,referer=140,acceptlanguage=135,cookie=98,ifnonematch=12,xclientdata=12,resourcefreshness=4,ifmodifiedsince=18,xrequestedwith=4,origin=3,authorization=1,cachecontrol=4,cachecontrol=4,date=1,pragma=1,location=1,acc=2,contentlength=1,xigcapabilities=28,dnt=64,xclientdata=15,purpose=1,xgeo=1,csp=3 value=0.1", 'w')
  if j == "204"
    puts "New table #{@mtable} created ..."
  else
    puts "Something when wrong error code #{j}"
  end
end
# Regexp strings first currently excludes POST Data
HTTP_METHODS_REGEXP = %r=^GET |^HEAD |^PUT |^TRACE |^CONNECT |^OPTIONS |^DELETE |^PROPFIND |^PROPPATCH |^MKCOL |^COPY |^MOVE |^LOCK |^UNLOCK =
HTTP_METHODS_REGEXP_RESPONSE = %r=^(HTTP\/.*)$=

httpdump = Pcaplet.new("-s 1500 -n -i #{@interface}")
HTTP_REQUEST  = Pcap::Filter.new('tcp dst port 80', httpdump.capture)
HTTP_RESPONSE = Pcap::Filter.new('tcp src portrange 1024-65535', httpdump.capture)

httpdump.add_filter(HTTP_REQUEST | HTTP_RESPONSE)
httpdump.each_packet {|pkt|
  begin
    data = pkt.tcp_data.to_s
    case pkt
    when HTTP_REQUEST
      if data =~ HTTP_METHODS_REGEXP
        path = $1
        host = pkt.dst.to_s
        host << ":#{pkt.dport}"
        s = "#{pkt.src}:#{pkt.sport} > GET http://#{host}#{path}".gsub("GET", "\e[1;36mGET\e[0m")
        puts "\e[1;31mRequest Data: #{data} \e[0m\ "
        makeurl(data)
        f = request_filter("#{@mtable}", data)
        r = sd.query("#{f}", 'w')
        puts "Response Code: #{r}"
        if r == "404" or r == "500"
          log_errors("/tmp/thm-httpseries-errors.log", "Code:#{r} - #{f}") # Catch them all
        end
      end
    when HTTP_RESPONSE
      if data =~ HTTP_METHODS_REGEXP_RESPONSE
        status = $1
        s = "#{pkt.dst}:#{pkt.dport} < #{status}"
        puts "\e[1;32mResponse Data: #{data} \e[0m\ "
        #f = filterdata("starbucks", data)
      end
    end
  rescue nil::NilClass => e
    pp e
  end
  puts s if s
}
